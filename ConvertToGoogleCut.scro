#!/bin/tclsh 

########################################################################
# This script converts a directory from a microscope (jp2 images)
# as tiles into a directory suitable for googles map display.
# Image names are changed to reflect the trsq convention and sub-sample
# images are created.
# The script uses ImageMagic functions to merge images and compute the
# sub-sample images.
#
# Last time called:
#    tclsh
#    source ConvertToGoogleCut.scro
#    compute 645 633 HT_1510_flipped .
#    (first two numbers are the rows and columns reported by DSS if
#    export is done as CWS, tile size 512, the first directory contains the
#    jpg images, the second directory contains the result in a Result/ directory)
#
# After creating the sub directires with all the image files they can be
# packaged for transport using:
#    zipSubDirs zipResult Result 3 1
#
# After transfering the tar-red files over to another machine, login there and
# call: for u in `ls zipResult/*.tar`; do tar xvf $u; done; cd Result; chmod 777 .
#
########################################################################

#
# Do a single tile using ImageMagick
# convert -verbose -page -50-50 /media/sf_Z_DRIVE/Hauke/RIL/Jp2/0001/000000_000066.jp2 \
#         -page +1450-50 /media/sf_Z_DRIVE/Hauke/RIL/Jp2/0001/000000_000067.jp2 \
#         -page -50+1050 /media/sf_Z_DRIVE/Hauke/RIL/Jp2/0001/000000_000092.jp2 \
#         -page +1450+1050 /media/sf_Z_DRIVE/Hauke/RIL/Jp2/0001/000000_000091.jp2 \
#         +page -alpha Set -virtual-pixel transparent -channel A -blur 5x5 -level 50,100% \
#         +channel \( -size 3000x2200 tile:empty.jpg -alpha set \) -insert 0 -background None -flatten /media/sf_Z_DRIVE/Hauke/RIL/Jp2/0001_output/test2.png
#
#


set inputDirectory "/media/sf_Z_DRIVE/Hauke/RIL/Jp2/0001"
set outputDirectory "/media/sf_Z_DRIVE/Hauke/RIL/Jp2/0001_output"
set scratch "/tmp/"
set tileSizeX 256
set tileSizeY 256
set subdirs 3

proc readAssemblyData { filename } {
    if { ![file readable $filename] } {
	puts "input file: $filename could not be read";
	return;
    }
    array set assembly { }
    set assembly(filename) $filename

    set fp [open $filename "r"]

    while { [gets $fp line] >= 0 } {
	set elements [string trim [split $line "="]]
        if { [llength $elements] == 2 } {
	    set a [string trim [lindex $elements 0]]
	    set b [string trim [lindex $elements 1]]
	    if { $a == "TrimLeft" } {
		set assembly(TrimLeft) $b
            }
	    if { $a == "TrimRight" } {
		set assembly(TrimRight) $b
            }
	    if { $a == "TrimTop" } {
		set assembly(TrimTop) $b
            }
	    if { $a == "TrimBottom" } {
		set assembly(TrimBottom) $b
            }
	    if { $a == "GridX" } {
		set assembly(GridX) $b
            }
	    if { $a == "GridY" } {
		set assembly(GridY) $b
            }
	    if { $a == "TileResolutionX" } {
		set assembly(TileResolutionX) $b
            }
	    if { $a == "TileResolutionY" } {
		set assembly(TileResolutionY) $b
            }
            if { [regexp {Tile([0-9]+)(X|Y)} $a all num xy] == 1 } {
                # convert to tile count which starts with 1
                set num [expr $num + 1]
                set vals [list 0 0]
                if { [info exists assembly($num)] } {
                   set vals $assembly($num)
                }
		if { $xy == "X" } {
		    set vals [list $b [lindex $vals 1]]
                } else {
		    set vals [list [lindex $vals 0] $b]
		}
                set assembly($num) $vals
            }
	}
    }

    close $fp
    # return as list

    # create the correct index pairs
    set tilex [expr $assembly(TileResolutionX)-$assembly(TrimLeft)-$assembly(TrimRight) ]
    set tiley [expr $assembly(TileResolutionY)-$assembly(TrimTop)-$assembly(TrimBottom) ]
    #set tilex [expr $assembly(TileResolutionX) - $assembly(TrimLeft) - $assembly(TrimRight)]
    #set tiley [expr $assembly(TileResolutionY) - $assembly(TrimTop) - $assembly(TrimBottom)]
    for { set idx 0 } { $idx < [expr $assembly(GridX) * $assembly(GridY)] } { incr idx } {
	if { [info exists assembly($idx)] } {
            # we have a tile at this location
	    set vals $assembly($idx)
	    set x [expr int(floor([lindex $vals 0]/$tilex))]
	    set y [expr int(floor([lindex $vals 1]/$tiley))]
            # puts "found x, y: $x, $y"
            set assembly($x-$y) $idx
	}
    }

    return [array get assembly]
}

# Create output tiles given overlapping input tiles
# input: the number of four tiles that can be concatenated
# output: writes the new tiles to the output directory
proc process4Tiles { one two three four idir odir loc } {
    global scratch
    global tileSizeX
    global tileSizeY
    global outputDirectory

    set cox [ lindex $loc 0]
    set coy [ lindex $loc 1]

    set ofn ${one}_${two}_${three}_${four}.png
    if { $one != "empty.jpg" } {
	set one  $idir/000000_[format "%06d" $one].jp2
    }
    if { $two != "empty.jpg" } {
	set two  $idir/000000_[format "%06d" $two].jp2
    }
    if { $three != "empty.jpg" } {
	set three  $idir/000000_[format "%06d" $three].jp2
    }
    if { $four != "empty.jpg" } {
	set four  $idir/000000_[format "%06d" $four].jp2
    }

    set result ${scratch}/$ofn

    if { [file exists $result] } {
       puts -nonewline "-"
       return
    }

    if { [catch {exec convert -page -50-50 $one -page +1450-50 $two -page -50+1050 $three -page +1450+1050 $four +page -alpha Set -virtual-pixel transparent -channel A -blur 5x5 -level 50,100% +channel \( -size 3000x2200 tile:empty.jpg -alpha set \) -insert 0 -background None -flatten $result} res] } {
	   puts "ERROR: from montage $res"
    } else {
	   puts -nonewline "x"
    }

    # now split this file into tiles based on our naming scheme
    # we need to export files that are numerically stacked

    # how many tiles will we have?
    set tilesInX [lindex $loc 2]
    set tilesInY [lindex $loc 3]
    set imsizex [expr 2*[lindex $loc 4]]
    set imsizey [expr 2*[lindex $loc 5]]
    #puts "total tiles: $tilesInX x $tilesInY, Image size: $imsizex x $imsizey"
    
    # what are the four corners that can contain tiles?
    set lx [expr ceil(1.0 * $cox / $tileSizeX)]
    set ly [expr ceil(1.0 * $coy / $tileSizeY)]
    set hx [expr floor(1.0 * ($cox+$imsizex) / $tileSizeX)]
    set hy [expr floor(1.0 * ($coy+$imsizey) / $tileSizeY)]
    set cornerLx [expr $lx*$tileSizeX]
    set cornerHx [expr $hx*$tileSizeX]
    set cornerLy [expr $ly*$tileSizeY]
    set cornerHy [expr $hy*$tileSizeY]
    #puts "corners ($cox,$coy): $cornerLx..$cornerHx, $cornerLy..$cornerHy"

    # we can now cut out this piece of the cake and convert it into tiles using 
    #    convert +gravity -crop ${tileSizeX}x${tileSizeY} tiles_%d.png
    set tilesDir [file rootname $result]
    file mkdir $tilesDir
#puts "convert $result -crop [expr int($cornerHx-$cornerLx)]x[expr int($cornerHy-$cornerLy)]+[expr int($cornerLx-$cox)]+[expr int($cornerLy-$coy)] +repage $tilesDir/cropped.png"
    if { [catch { exec convert $result -crop [expr int($cornerHx-$cornerLx)]x[expr int($cornerHy-$cornerLy)]+[expr int($cornerLx-$cox)]+[expr int($cornerLy-$coy)] +repage $tilesDir/cropped.png } res] } {
       puts "ERROR: could not crop the image to fix the tile size ($res)"
    } else {
       #puts -nonewline ":"
    }

    #puts "convert +gravity -crop ${tileSizeX}x${tileSizeY} $tilesDir/cropped.png $tilesDir/tiles_\%d.png"
    if { [catch { exec convert +gravity -crop ${tileSizeX}x${tileSizeY} $tilesDir/cropped.png $tilesDir/tiles_\%02d.jpg } res] } {
        puts "ERROR: could not split the first merged tile ($res)"
    } else {
        #puts -nonewline ":"
    }

    # all of these tiles have to be renamed now according to the number in the sequence
    set count 0
    for { set y [expr int($ly)] } { $y < $hy } { incr y } {
      for { set x [expr int($lx)] } { $x < $hx } { incr x } {
          # x and y are in terms of cox and coy number of tiles
          # compute the index of a tile
	  set idx [expr $y * $cox + $x]
          #puts -nonewline ", Da${idx}.jpg (tiles_[format %02d $count].jpg)"
          file copy -force -- $tilesDir/tiles_[format %02d $count].jpg ${outputDirectory}/Da${idx}.jpg
          set count [expr $count + 1]
      }
    }
    #puts "count is $count, should be ($hx - $lx * $hy - $ly)"
    
    # clean up
    file delete -force -- $tilesDir
    file delete -force -- $result
}

proc computeFirstLevel { maxX maxY idir odir assembly } {
    global scratch
    global tileSizeX tileSizeY

    array set asem $assembly
    puts "we have access to the assembly here: $asem(GridX)"
    puts "run this for $maxX x $maxY"
    set first 0
    set ars [list -1 -1 -1 -1]

    set totalX [expr ($asem(TileResolutionX)-$asem(TrimLeft)-$asem(TrimRight)) * $asem(GridX) ]
    set totalY [expr ($asem(TileResolutionY)-$asem(TrimTop)-$asem(TrimBottom)) * $asem(GridY) ]
    set tilesInX [expr ceil($totalX/$tileSizeX)]
    set tilesInY [expr ceil($totalY/$tileSizeY)]

    # find out the order of tiles, start with the first tile and arrange them into a 2x2 grid
    for { set j 0 } { $j < $maxY } { incr j } {
       for { set i 0 } { $i < $maxX } { incr i } {
          if { [info exists asem($i-$j)] } {
              set idx1 $i-$j

              # what are the coordinates of the small tiles?
              #set cox [expr $i * $totalX/$maxX]
              #set coy [expr $j * $totalY/$maxY]
              set cox [lindex $asem($asem($idx1)) 0]
              set coy [lindex $asem($asem($idx1)) 1]
              # tiles mentioned in the assembly start counting from 0, asm encodes them starting with 1
              #puts "coordinates for Tile[expr $asem($idx1)-1]X/Y are $cox x $coy"

              # find four parts
              set one  $asem($idx1)
              set idx2 [expr $i+1]-[expr $j+0]
              if { [info exists asem($idx2)] } {
   	         set two $asem($idx2)
              } else {
                 set two "empty.jpg"
	      }
              set idx3 [expr $i+0]-[expr $j+1]
              if { [info exists asem($idx3)] } {
	         set three $asem($idx3)
              } else {
                 set three "empty.jpg"
	      }
              set idx4 [expr $i+1]-[expr $j+1]
              if { [info exists asem($idx4)] } {
  	         set four  $asem($idx4)
              } else {
                 set four "empty.jpg"
	      }
              set ars [list $idx1 $idx2 $idx3 $idx4]

              #set first [expr $first + 1]
  	      #if { $first == 52 } {
              #    set first 101
              #    # puts "$one, $two; $three, $four"
              #}
              # puts -nonewline "x"
              # now process the four tiles
              process4Tiles $one $two $three $four $idir $odir [list $cox $coy $tilesInX $tilesInY  [expr $asem(TileResolutionX)-$asem(TrimLeft)-$asem(TrimRight)] [expr  $asem(TileResolutionY)-$asem(TrimTop)-$asem(TrimBottom)] ]
          } else {
             puts -nonewline "."
          }
          flush stdout
      }
      puts ""
    }
}

set asem [readAssemblyData $inputDirectory/AssemblyData.txt]
# convert back to array
array unset assembly
array set assembly $asem
puts [array names assembly]

if { [info exists assembly(TrimLeft)] } {
    puts "TrimLeft: $assembly(TrimLeft), $assembly(TrimRight)"
} else {
    puts "TrimLeft could not be found";
}
if { [info exists assembly(GridX)] } {
    puts "GridX: $assembly(GridX) x $assembly(GridY)"
} else {
    puts "GridX could not be found";
}
if { [info exists assembly(TileResolutionX)] } {
    puts "TileResolution: $assembly(TileResolutionX) x $assembly(TileResolutionY)"
} else {
    puts "TileResolutionX/Y could not be found";
}


# now create a tile cache that is compatible with the rest
set maxX [expr ($assembly(TileResolutionX)-$assembly(TrimLeft)-$assembly(TrimRight)) * $assembly(GridX) ]
set maxY [expr ($assembly(TileResolutionY)-$assembly(TrimTop)-$assembly(TrimBottom)) * $assembly(GridY) ]
puts "total size of image will be $maxX x $maxY which maps to 000000_[format %06d [expr 1]] ... 000000_[format %06d [expr $assembly(GridX) * $assembly(GridY)]] (some might be missing)"


computeFirstLevel $assembly(GridX) $assembly(GridY) $inputDirectory $outputDirectory [array get assembly]


proc compute { maxX maxY idir odir } {
    global subdirs

    puts "This script expects three parameters, two for the number of tiles in X and Y and one as a filename"

    set d $odir
    if { $d == "" } {
	puts "Error: no input directory provided"
	return
    }
	
    set dir [file dirname $d]
    file mkdir ${dir}/Result
    set outputDir ${dir}/Result
    createSubDirs $outputDir $subdirs 1
	
    #
    #   T
    #
    #   TQ | TR
    #   TT | TS
    #

    #
    #  0_0 0_1 | 0_2 0_3
    #  1_0 1_1 | 1_2 1_3
    #  --------|--------
    #  2_0 2_1 | 2_2 2_3
    #  3_0 3_1 | 3_2 3_3
    #
    
    # how many level do we have to do to get one image?
    set level 1
    set tmp [expr $maxY + 1]
    while { [expr $tmp/2] > 1 } { incr level; set tmp [expr $tmp/2]; }
    puts "We need $level different levels"
    
    # build the last minus 1 level interpolation
    set ic 0
    set jc 0
	
#    workArea startWorking "Computing..."
if { true } {
    for { set i 0 } { $i < $maxX } { set i [expr $i + 2] } {

 	puts "Computing $i of $maxX"

	set jc 0
	for { set j 0 } { $j < $maxY } { set j [expr $j + 2] } {
	    set A [expr $i * $maxY + $j]
	    set B [expr $i * $maxY + ($j+1)]
	    set C [expr ($i+1) * $maxY + $j]
	    set D [expr ($i+1) * $maxY + ($j+1)]
	    # set A "${i}_${j}"
	    # set B "${i}_[expr ${j}+1]"
	    # set C "[expr ${i}+1]_${j}"
	    # set D "[expr ${i}+1]_[expr ${j}+1]"
	    #puts " $A $B - Q R  [tilename ${i} ${j} [expr $level+1] $subdirs] [tilename ${i} [expr ${j}+1] [expr $level+1] $subdirs]"
	    #puts " $C $D - T S  [tilename [expr ${i}+1] ${j} [expr $level+1] $subdirs] [tilename [expr ${i} + 1] [expr ${j} + 1] [expr $level+1] $subdirs]"
	    
	    puts "call tilename ${ic} ${jc} $level"
	    set result [tilename ${ic} ${jc} $level $subdirs]
	    #puts "Create: $result"
         if { ![file exists ${outputDir}/${result}.jpg] } {
		   # touch the file to indicate that we own it
		   set f [open ${outputDir}/${result}.jpg "w"]; close $f;
	       merge4 ${idir}/Da${A}.jpg ${idir}/Da${B}.jpg ${idir}/Da${C}.jpg ${idir}/Da${D}.jpg ${outputDir}/${result}.jpg
	    
	       # copy the input data as highest resolution level into output
            if { [catch {file copy -force ${idir}/Da${A}.jpg ${outputDir}/[tilename ${i} ${j} [expr $level+1] $subdirs].jpg} res] } {
	          puts "ERROR copying: $res"
            }
            if { [catch {file copy -force ${idir}/Da${B}.jpg ${outputDir}/[tilename ${i} [expr ${j}+1] [expr $level+1] $subdirs].jpg} res] } {
	          puts "ERROR copying: $res"
            }
            if { [catch {file copy -force ${idir}/Da${C}.jpg ${outputDir}/[tilename [expr ${i}+1] ${j} [expr $level+1] $subdirs].jpg} res ] } {
	          puts "ERROR copying: $res"
            }
            if { [catch {file copy -force ${idir}/Da${D}.jpg ${outputDir}/[tilename [expr ${i}+1] [expr ${j}+1] [expr $level+1] $subdirs].jpg} res] } {
	          puts "ERROR copying: $res"
            }
           }
	    incr jc
       	}
	incr ic
    }
} 
# END FALSE

    # for all other levels we can merge the previously build tiles
    while { $level > 0 } {
	puts "create images for level $level"

	set maxX [expr ceil($maxX/2.0)]
	set maxY [expr ceil($maxY/2.0)]
	set ic 0
	set jc 0

	puts "Images at level $level: $maxX x $maxY"
	for { set i 0 } { $i < $maxX } { set i [expr $i + 2] } {
	    set jc 0
	    for { set j 0 } { $j < $maxY } { set j [expr $j + 2] } {
		set A [tilename ${i} ${j} $level $subdirs]
		set B [tilename ${i} [expr ${j} + 1] $level $subdirs]
		set C [tilename [expr ${i}+1] ${j} $level $subdirs]
		set D [tilename [expr ${i}+1] [expr ${j} + 1] $level $subdirs]
		
		puts " $A $B "
		puts " $C $D  call tilename ${ic} ${jc} [expr $level -1]"
		set result [tilename ${ic} ${jc} [expr $level - 1] $subdirs]
		if { ![file exists ${outputDir}/${result}.jpg] } { 
		   # touch the file to indicate that we own it
		   set f [open ${outputDir}/${result}.jpg "w"]; close $f;
  		   merge4 ${outputDir}/${A}.jpg ${outputDir}/${B}.jpg ${outputDir}/${C}.jpg ${outputDir}/${D}.jpg ${outputDir}/${result}.jpg
		}
				
		incr jc
	    }
	    incr ic
	}

	set level [expr $level - 1]
    }
}

# call with 3 to recreate the last three stages
# assumes that images below that level already exist
proc createLastStages { } {
    # assume we are in the Result directory
    set level 3
    set outputDir "."
    set subdirs 1
    set maxX [expr pow(2,$level)]
    set maxY $maxX
    set ic 0
    set jc 0

   puts "images for level: $level"
   for { set i 0 } { $i < $maxX } { set i [expr $i + 2] } {
            set jc 0
            for { set j 0 } { $j < $maxY } { set j [expr $j + 2] } {
                set A [tilename ${i} ${j} $level $level]
                set B [tilename ${i} [expr ${j} + 1] $level $level]
                set C [tilename [expr ${i}+1] ${j} $level $level]
                set D [tilename [expr ${i}+1] [expr ${j} + 1] $level $level]
                if { ![file exists ${outputDir}/${A}.jpg] } {
                   continue;
                }
                
                puts " $A $B "
                puts " $C $D  call tilename ${ic} ${jc} [expr $level -1]"
                set result [tilename ${ic} ${jc} [expr $level - 1] [expr $level-1]]
                puts "we would create file ${outputDir}/${result}.jpg now"
                if { ![file exists ${outputDir}/${result}.jpg] } { 
                   # touch the file to indicate that we own it
                   set f [open ${outputDir}/${result}.jpg "w"]; close $f;
                   merge4 ${outputDir}/${A}.jpg ${outputDir}/${B}.jpg ${outputDir}/${C}.jpg ${outputDir}/${D}.jpg ${outputDir}/${result}.jpg
                }
                incr jc
            }
            incr ic
    }
    set level 2
    set outputDir "."
    set subdirs 1
    set maxX [expr pow(2,$level)]
    set maxY $maxX
    set ic 0
    set jc 0

   puts "images for level: $level"
   for { set i 0 } { $i < $maxX } { set i [expr $i + 2] } {
            set jc 0
            for { set j 0 } { $j < $maxY } { set j [expr $j + 2] } {
                set A [tilename ${i} ${j} $level $level]
                set B [tilename ${i} [expr ${j} + 1] $level $level]
                set C [tilename [expr ${i}+1] ${j} $level $level]
                set D [tilename [expr ${i}+1] [expr ${j} + 1] $level $level]
                if { ![file exists ${outputDir}/${A}.jpg] } {
                   continue;
                }

                puts " $A $B "
                puts " $C $D  call tilename ${ic} ${jc} [expr $level -1]"
                set result [tilename ${ic} ${jc} [expr $level - 1] 0]
                if { ![file exists ${outputDir}/${result}.jpg] } { 
                   # touch the file to indicate that we own it
                   set f [open ${outputDir}/${result}.jpg "w"]; close $f;
                   merge4 ${outputDir}/${A}.jpg ${outputDir}/${B}.jpg ${outputDir}/${C}.jpg ${outputDir}/${D}.jpg ${outputDir}/${result}.jpg
                   puts "we would create file ${outputDir}/${result}.jpg now"
                }
                incr jc
            }
            incr ic
    }
    # last image
    merge4 ${outputDir}/tq.jpg ${outputDir}/tr.jpg ${outputDir}/tt.jpg ${outputDir}/ts.jpg ${outputDir}/t.jpg
}

# create all the directories requires recursively
# call this with startdir 3 1
proc createSubDirs { startDir levelsTotal level } {
   file mkdir $startDir/q
   if { $level < $levelsTotal } {
      createSubDirs $startDir/q $levelsTotal [expr $level + 1]
   }
   file mkdir $startDir/r
   if { $level < $levelsTotal } {
      createSubDirs $startDir/r $levelsTotal [expr $level + 1]
   }
   file mkdir $startDir/s
   if { $level < $levelsTotal } {
      createSubDirs $startDir/s $levelsTotal [expr $level + 1]
   }
   file mkdir $startDir/t
   if { $level < $levelsTotal } {
      createSubDirs $startDir/t $levelsTotal [expr $level + 1]
   }
}
# call this with zipdir startdir 3 1
proc zipSubDirs { resultDir startDir levelsTotal level } {
   if { ![file isdirectory $resultDir] } {
      file mkdir $resultDir
   }
   #file mkdir $startDir/q
   if { [llength [glob -nocomplain $startDir/q/*.jpg]] > 0 } {
     exec find $startDir/q/ -maxdepth 1 -name "*.jpg" | xargs tar rvf $resultDir/[join [split $startDir "/"] "_"]_q.tar
   }
   if { $level < $levelsTotal } {
      zipSubDirs $resultDir $startDir/q $levelsTotal [expr $level + 1]
   }
   #file mkdir $startDir/r
   if { [llength [glob -nocomplain $startDir/r/*.jpg]] > 0 } {
     exec find $startDir/r/ -maxdepth 1 -name "*.jpg" | xargs tar rvf $resultDir/[join [split $startDir "/"] "_"]_r.tar
   }
   if { $level < $levelsTotal } {
      zipSubDirs $resultDir $startDir/r $levelsTotal [expr $level + 1]
   }
   #file mkdir $startDir/s
   if { [llength [glob -nocomplain $startDir/s/*.jpg]] > 0 } {
     exec find $startDir/s/ -maxdepth 1 -name "*.jpg" | xargs tar rvf $resultDir/[join [split $startDir "/"] "_"]_s.tar
   }
   if { $level < $levelsTotal } {
      zipSubDirs $resultDir $startDir/s $levelsTotal [expr $level + 1]
   }
   #file mkdir $startDir/t
   if { [llength [glob -nocomplain $startDir/t/*.jpg]] > 0 } {
     exec find $startDir/t/ -maxdepth 1 -name "*.jpg" | xargs tar rvf $resultDir/[join [split $startDir "/"] "_"]_t.tar
   }
   if { $level < $levelsTotal } {
      zipSubDirs $resultDir $startDir/t $levelsTotal [expr $level + 1]
   }
}

proc merge4 { A B C D result } {
    global env tileSizeX tileSizeY
    # create from 4 256x256 images a new 128x128 image with a 2x2 layout

    set count 0
    if { ![file exists $A] } {
       set A empty.jpg
       incr count
    }
    if { ![file exists $B] } {
       set B empty.jpg
       incr count
    }
    if { ![file exists $C] } {
       set C empty.jpg
       incr count
    }
    if { ![file exists $D] } {
       set D empty.jpg
       incr count
    }

    # no sense in creating a fully empty tile, this should save some memory
    if { $count == 4 } {
       return;
    }
    if { [catch {exec montage -font Bookman $A $B $C $D -interlace plane -geometry [expr ${tileSizeX}/2]x[expr ${tileSizeY}/2]+0+0 $result} res] } {
	   puts "ERROR: from montage $res"
    } else {
	   puts "created: \"$result\""
    }
}

proc tilename { j i level subdirs} {
    set c [expr pow(2,$level)]
    set d ${i}
    set e ${j}
    set f "t"
    for { set g 0 } { $g < $level } { incr g } {
  	  set c [expr $c/2]
	  if { $e < $c } {
	    if { $d < $c } {
		set f "${f}q"
	    } else {
		set f "${f}r"
		set d [expr ${d} - ${c}]
	    }
	  } else {
	    if { $d < $c } {
		set f "${f}t"
		set e [expr ${e} - ${c}]
	    } else {
		set f "${f}s"
		set d [expr ${d} - ${c}]
		set e [expr ${e} - ${c}]
	    }
	  }
    }
    set tmp ""
    if { [string length $f] >= $subdirs } {
        for { set i 0 } { $i < $subdirs} { incr i } {
               set tmp $tmp[string index $f $i]/
        }
    }
    set tmp ${tmp}$f
    return $tmp;
}
